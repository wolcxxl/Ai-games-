<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Snake AI - Fixed & Fast</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@500;900&display=swap');

        /* –°–±—Ä–æ—Å –∏ –±–∞–∑–∞ */
        * { box-sizing: border-box; touch-action: none; user-select: none; -webkit-tap-highlight-color: transparent; }
        body {
            background-color: #121212;
            font-family: 'Roboto', sans-serif;
            margin: 0; padding: 0;
            height: 100vh; width: 100vw;
            display: flex; flex-direction: column;
            align-items: center; justify-content: flex-start; /* –ò–∑–º–µ–Ω–µ–Ω–æ –¥–ª—è –º–æ–±–∏–ª–æ–∫ */
            color: white;
            overflow: hidden;
        }

        /* –ì–ª–∞–≤–Ω—ã–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä */
        #game-wrapper {
            width: 100%; max-width: 500px;
            height: 100%;
            display: flex; flex-direction: column;
            padding: 10px;
        }

        /* –®–∞–ø–∫–∞ */
        #header {
            display: flex; justify-content: space-between; align-items: center;
            background: #1f1f1f; padding: 15px; border-radius: 12px;
            margin-bottom: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .score { font-size: 1.5rem; font-weight: 900; display: flex; align-items: center; gap: 10px; }
        .badge { background: #333; padding: 5px 10px; border-radius: 6px; font-size: 0.8rem; font-family: monospace; }

        /* –ò–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ */
        #board-container {
            position: relative;
            width: 100%;
            aspect-ratio: 1;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        canvas { display: block; width: 100%; height: 100%; }

        /* –ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è (–Ω–∏–∑) */
        #controls-panel {
            margin-top: 10px;
            background: #1f1f1f;
            padding: 10px;
            border-radius: 12px;
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 10px;
            align-items: center;
        }

        .btn {
            background: #333; border: none; color: white;
            padding: 12px; border-radius: 8px; font-weight: bold;
            cursor: pointer; transition: 0.1s; text-align: center;
        }
        .btn:active { transform: scale(0.95); background: #555; }
        .btn.active { background: #00E676; color: #003300; }
        
        .speed-controls { display: flex; gap: 5px; justify-content: center; }
        .spd-btn { padding: 10px 15px; background: #333; border-radius: 6px; border: none; color: #aaa; font-weight: bold; }
        .spd-btn.active { background: #FFD700; color: black; }

        /* –≠–∫—Ä–∞–Ω–Ω—ã–µ –∫–Ω–æ–ø–∫–∏ (D-Pad) */
        #dpad {
            margin-top: auto; /* –ü—Ä–∏–∂–∞—Ç—å –∫ –Ω–∏–∑—É */
            margin-bottom: 10px;
            display: grid; 
            grid-template-columns: repeat(3, 1fr); 
            grid-template-rows: repeat(2, 60px);
            gap: 8px;
            width: 100%;
            max-width: 300px;
            align-self: center;
        }
        .d-btn {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            display: flex; align-items: center; justify-content: center;
            font-size: 24px;
        }
        .d-btn:active { background: rgba(255,255,255,0.3); }
        /* –†–∞—Å–∫–ª–∞–¥–∫–∞ –∫–Ω–æ–ø–æ–∫ */
        .d-up { grid-column: 2; grid-row: 1; }
        .d-left { grid-column: 1; grid-row: 2; }
        .d-down { grid-column: 2; grid-row: 2; }
        .d-right { grid-column: 3; grid-row: 2; }

        /* –û–≤–µ—Ä–ª–µ–∏ */
        .overlay {
            position: absolute; inset: 0;
            background: rgba(0,0,0,0.85);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 50;
        }
        .hidden { display: none !important; }

        .play-btn-big {
            width: 80px; height: 80px; background: #00E676;
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            box-shadow: 0 0 30px rgba(0,230,118,0.5); cursor: pointer;
        }

    </style>
</head>
<body>
<a href="../" style="
    position: fixed;
    top: 15px;
    left: 15px;
    z-index: 9999;
    background-color: rgba(30, 30, 46, 0.8);
    color: #fff;
    padding: 10px 20px;
    text-decoration: none;
    border-radius: 8px;
    font-family: sans-serif;
    border: 1px solid #00c6ff;
    font-weight: bold;
    box-shadow: 0 0 10px rgba(0,0,0,0.5);
    transition: 0.3s;
" onmouseover="this.style.backgroundColor='#00c6ff'" onmouseout="this.style.backgroundColor='rgba(30, 30, 46, 0.8)'">
    üè† –î–æ–º–æ–π
</a>
<div id="game-wrapper">
    <!-- –®–∞–ø–∫–∞ -->
    <div id="header">
        <div class="score">üçé <span id="score-val">0</span></div>
        <div class="badge" id="ai-status">MANUAL</div>
    </div>

    <!-- –ü–æ–ª–µ -->
    <div id="board-container">
        <canvas id="gameCanvas"></canvas>
        
        <!-- –°—Ç–∞—Ä—Ç -->
        <div id="start-screen" class="overlay">
            <div class="play-btn-big" id="btn-start">
                <svg width="40" height="40" viewBox="0 0 24 24" fill="white"><path d="M8 5v14l11-7z"/></svg>
            </div>
            <p style="color:#888; margin-top:15px;">–ù–∞–∂–º–∏ Play</p>
        </div>

        <!-- –ö–æ–Ω–µ—Ü -->
        <div id="game-over-screen" class="overlay hidden">
            <h1 style="color:#ff5252; margin:0 0 10px;">GAME OVER</h1>
            <p style="font-size:1.2rem;">–°—á–µ—Ç: <span id="final-score">0</span></p>
            <button class="btn" id="btn-restart" style="background:#2196F3; margin-top:20px; width:150px;">–ó–∞–Ω–æ–≤–æ</button>
        </div>
    </div>

    <!-- –ù–∞—Å—Ç—Ä–æ–π–∫–∏ -->
    <div id="controls-panel">
        <button class="btn" id="btn-toggle-ai">BOT</button>
        <div class="speed-controls">
            <button class="spd-btn active" data-spd="1">1x</button>
            <button class="spd-btn" data-spd="20">20x</button>
            <button class="spd-btn" data-spd="max">MAX</button>
        </div>
        <div style="text-align:center; font-size:0.8rem; color:#555;">SPEED</div>
    </div>

    <!-- –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è -->
    <div id="dpad">
        <div class="d-btn d-up" data-key="ArrowUp">‚ñ≤</div>
        <div class="d-btn d-left" data-key="ArrowLeft">‚óÄ</div>
        <div class="d-btn d-down" data-key="ArrowDown">‚ñº</div>
        <div class="d-btn d-right" data-key="ArrowRight">‚ñ∂</div>
    </div>
</div>

<script>
    // --- –ù–ê–°–¢–†–û–ô–ö–ò ---
    const TILE_COUNT = 15; // 15x15 (–æ–ø—Ç–∏–º–∞–ª—å–Ω–æ –¥–ª—è —Ç–µ–ª–µ—Ñ–æ–Ω–∞)
    const COLOR_BG_1 = '#1a1a1a';
    const COLOR_BG_2 = '#222';
    const COLOR_SNAKE = '#00E676';
    const COLOR_FOOD = '#ff5252';

    // --- –ü–ï–†–ï–ú–ï–ù–ù–´–ï ---
    let canvas, ctx;
    let width, height, tileSize;
    
    let snake = [];
    let food = {x:0, y:0};
    let dir = {x:1, y:0};
    let nextDir = {x:1, y:0};
    let score = 0;
    
    let isRunning = false;
    let isAI = false;
    let speedLevel = 1; // 1, 20, 100 (max)
    let loopId = null;

    // --- –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ---
    window.onload = () => {
        canvas = document.getElementById('gameCanvas');
        ctx = canvas.getContext('2d');
        
        // –õ–∏—Å—Ç–µ–Ω–µ—Ä—ã –∫–Ω–æ–ø–æ–∫
        document.getElementById('btn-start').onclick = startGame;
        document.getElementById('btn-restart').onclick = startGame;
        document.getElementById('btn-toggle-ai').onclick = toggleAI;
        
        // –°–∫–æ—Ä–æ—Å—Ç—å
        document.querySelectorAll('.spd-btn').forEach(btn => {
            btn.onclick = (e) => {
                document.querySelectorAll('.spd-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                const val = e.target.getAttribute('data-spd');
                speedLevel = val === 'max' ? 100 : parseInt(val);
            };
        });

        // D-PAD –∏ –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞
        setupControls();
        
        // –†–µ—Å–∞–π–∑
        window.onresize = resize;
        resize();
    };

    function resize() {
        const container = document.getElementById('board-container');
        width = container.clientWidth;
        height = container.clientHeight; // –î–æ–ª–∂–µ–Ω –±—ã—Ç—å –∫–≤–∞–¥—Ä–∞—Ç
        canvas.width = width;
        canvas.height = height;
        tileSize = width / TILE_COUNT;
        if (!isRunning) draw();
    }

    function setupControls() {
        // –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞
        document.addEventListener('keydown', e => {
            if (isAI && isRunning) return;
            handleInput(e.key);
        });

        // –≠–∫—Ä–∞–Ω–Ω—ã–µ –∫–Ω–æ–ø–∫–∏ (Touch + Click)
        document.querySelectorAll('.d-btn').forEach(btn => {
            const handler = (e) => {
                e.preventDefault(); // –ß—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –¥–∞–±–ª-–∫–ª–∏–∫–∞
                if (isAI && isRunning) return;
                handleInput(btn.getAttribute('data-key'));
            };
            btn.addEventListener('touchstart', handler);
            btn.addEventListener('mousedown', handler);
        });

        // –°–≤–∞–π–ø—ã
        let tx = 0, ty = 0;
        const board = document.getElementById('board-container');
        board.addEventListener('touchstart', e => {
            tx = e.changedTouches[0].screenX;
            ty = e.changedTouches[0].screenY;
            e.preventDefault();
        }, {passive: false});

        board.addEventListener('touchend', e => {
            if (isAI && isRunning) return;
            const dx = e.changedTouches[0].screenX - tx;
            const dy = e.changedTouches[0].screenY - ty;
            if (Math.abs(dx) > Math.abs(dy)) {
                if (Math.abs(dx) > 30) handleInput(dx > 0 ? 'ArrowRight' : 'ArrowLeft');
            } else {
                if (Math.abs(dy) > 30) handleInput(dy > 0 ? 'ArrowDown' : 'ArrowUp');
            }
        });
    }

    function handleInput(key) {
        switch(key) {
            case 'ArrowUp': case 'w': if(dir.y !== 1) nextDir = {x:0, y:-1}; break;
            case 'ArrowDown': case 's': if(dir.y !== -1) nextDir = {x:0, y:1}; break;
            case 'ArrowLeft': case 'a': if(dir.x !== 1) nextDir = {x:-1, y:0}; break;
            case 'ArrowRight': case 'd': if(dir.x !== -1) nextDir = {x:1, y:0}; break;
        }
    }

    // --- –ò–ì–†–û–í–û–ô –¶–ò–ö–õ ---
    function startGame() {
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.add('hidden');
        
        snake = [{x:5, y:8}, {x:4, y:8}, {x:3, y:8}];
        dir = {x:1, y:0};
        nextDir = {x:1, y:0};
        score = 0;
        updateUI();
        placeFood();
        
        isRunning = true;
        if (loopId) clearTimeout(loopId);
        gameLoop();
    }

    function gameLoop() {
        if (!isRunning) return;

        // –ï—Å–ª–∏ –±–æ—Ç –≤–∫–ª—é—á–µ–Ω –∏ —Å–∫–æ—Ä–æ—Å—Ç—å MAX, –¥–µ–ª–∞–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ —à–∞–≥–æ–≤ –∑–∞ –∫–∞–¥—Ä
        // –ù–û —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º, —á—Ç–æ–±—ã –Ω–µ –ø–æ–≤–µ—Å–∏—Ç—å –±—Ä–∞—É–∑–µ—Ä (–º–∞–∫—Å 10 —à–∞–≥–æ–≤ –∑–∞ —Ä–∞–∑)
        const steps = (isAI && speedLevel > 20) ? 5 : 1;
        const delay = (isAI && speedLevel > 20) ? 10 : (100 / (speedLevel === 1 ? 1 : 2));

        for (let i = 0; i < steps; i++) {
            update();
            if (!isRunning) break;
        }
        
        draw();
        
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º setTimeout –¥–ª—è –∫–æ–Ω—Ç—Ä–æ–ª—è —Å–∫–æ—Ä–æ—Å—Ç–∏
        loopId = setTimeout(() => requestAnimationFrame(gameLoop), delay);
    }

    function update() {
        // AI –õ–æ–≥–∏–∫–∞
        if (isAI) runAI();
        else dir = nextDir;

        const head = snake[0];
        const nx = head.x + dir.x;
        const ny = head.y + dir.y;

        // –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Å–æ —Å—Ç–µ–Ω–æ–π
        if (nx < 0 || nx >= TILE_COUNT || ny < 0 || ny >= TILE_COUNT) {
            return gameOver();
        }

        // –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Å —Å–æ–±–æ–π
        // –•–≤–æ—Å—Ç –±–µ–∑–æ–ø–∞—Å–µ–Ω, –µ—Å–ª–∏ –º—ã –Ω–µ –µ–¥–∏–º (–æ–Ω —É–ø–æ–ª–∑–µ—Ç)
        let hitSelf = false;
        for (let i = 0; i < snake.length - 1; i++) { // -1 –ø–æ—Ç–æ–º—É —á—Ç–æ —Ö–≤–æ—Å—Ç —É—Ö–æ–¥–∏—Ç
            if (nx === snake[i].x && ny === snake[i].y) {
                hitSelf = true;
                break;
            }
        }
        if (hitSelf) return gameOver();

        // –î–≤–∏–∂–µ–Ω–∏–µ
        const newHead = {x:nx, y:ny};
        snake.unshift(newHead);

        // –ï–¥–∞
        if (nx === food.x && ny === food.y) {
            score++;
            updateUI();
            placeFood();
        } else {
            snake.pop();
        }
    }

    function gameOver() {
        isRunning = false;
        document.getElementById('final-score').innerText = score;
        document.getElementById('game-over-screen').classList.remove('hidden');
    }

    function placeFood() {
        let attempts = 0;
        while (attempts < 500) {
            const x = Math.floor(Math.random() * TILE_COUNT);
            const y = Math.floor(Math.random() * TILE_COUNT);
            // –ü—Ä–æ–≤–µ—Ä–∫–∞, –Ω–µ –Ω–∞ –∑–º–µ–µ –ª–∏
            if (!snake.some(s => s.x === x && s.y === y)) {
                food = {x, y};
                return;
            }
            attempts++;
        }
    }

    // --- –£–ú–ù–´–ô –ë–û–¢ (Survival Logic Optimized) ---
    function runAI() {
        const head = snake[0];
        
        // 1. –ò—â–µ–º –ø—É—Ç—å –∫ –µ–¥–µ (BFS)
        const pathToFood = bfs(head, food, snake);
        
        let bestMove = null;

        if (pathToFood.length > 0) {
            // 2. SAFETY CHECK: –ï—Å–ª–∏ —Å—ä–µ–¥–∏–º, —Å–º–æ–∂–µ–º –ª–∏ –Ω–∞–π—Ç–∏ —Ö–≤–æ—Å—Ç?
            // –°–∏–º—É–ª—è—Ü–∏—è –ø—Ä–æ—Å—Ç–∞—è: –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ –≥–æ–ª–æ–≤–∞ —Å—Ç–∞–Ω–µ—Ç –Ω–∞ –º–µ—Å—Ç–æ –ø–µ—Ä–≤–æ–≥–æ —à–∞–≥–∞, –∞ —Ö–≤–æ—Å—Ç –æ—Å—Ç–∞–Ω–µ—Ç—Å—è (—Ç.–∫. —Å—ä–µ–ª–∏ = –≤—ã—Ä–æ—Å–ª–∏)
            // –≠—Ç–æ –≥—Ä—É–±–∞—è, –Ω–æ –±—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞
            const nextStep = pathToFood[0];
            const virtualSnake = [nextStep, ...snake]; 
            // –ü—Ä–∏ –ø–æ–µ–¥–∞–Ω–∏–∏ —Ö–≤–æ—Å—Ç –Ω–µ —É–¥–∞–ª—è–µ—Ç—Å—è, –¥–ª–∏–Ω–∞ —Ä–∞—Å—Ç–µ—Ç. 
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—É—Ç—å –æ—Ç –Ω–æ–≤–æ–π –≥–æ–ª–æ–≤—ã –∫ –¢–ï–ö–£–©–ï–ú–£ —Ö–≤–æ—Å—Ç—É (–æ–Ω —Å—Ç–∞–Ω–µ—Ç –∫–æ–Ω—Ü–æ–º)
            const virtualTail = snake[snake.length-1]; 
            
            if (canReach(nextStep, virtualTail, virtualSnake)) {
                bestMove = nextStep;
            }
        }

        // 3. –ï—Å–ª–∏ –∫ –µ–¥–µ –æ–ø–∞—Å–Ω–æ –∏–ª–∏ –Ω–µ—Ç –ø—É—Ç–∏ -> –ò–¥–µ–º –∫ —Ö–≤–æ—Å—Ç—É (—Ç—è–Ω–µ–º –≤—Ä–µ–º—è)
        if (!bestMove) {
            const tail = snake[snake.length-1];
            // –ü—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ –ø—É—Ç—å –∫ —Ö–≤–æ—Å—Ç—É. –•–≤–æ—Å—Ç –æ—Å–≤–æ–±–æ–¥–∏—Ç—Å—è, –ø–æ—ç—Ç–æ–º—É –æ–Ω –≤–∞–ª–∏–¥–Ω–∞—è —Ü–µ–ª—å.
            // –ù—É–∂–Ω–æ –≤—ã–±—Ä–∞—Ç—å —Å–æ—Å–µ–¥–∞, –æ—Ç –∫–æ—Ç–æ—Ä–æ–≥–æ –ø—É—Ç—å –∫ —Ö–≤–æ—Å—Ç—É —Å–∞–º—ã–π –¥–ª–∏–Ω–Ω—ã–π (–∏–ª–∏ –ø—Ä–æ—Å—Ç–æ –µ—Å—Ç—å).
            const neighbors = getNeighbors(head).filter(n => isValid(n, snake));
            
            for (let n of neighbors) {
                // –ï—Å–ª–∏ –º—ã –ø–æ–π–¥–µ–º –≤ n, –∑–º–µ—è —Å–¥–≤–∏–Ω–µ—Ç—Å—è. –•–≤–æ—Å—Ç –±—É–¥–µ—Ç –Ω–∞ –º–µ—Å—Ç–µ –ø—Ä–µ–¥–ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Å–µ–≥–º–µ–Ω—Ç–∞.
                // –ù–æ –¥–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã: –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —Ö–≤–æ—Å—Ç–∞
                if (canReach(n, tail, snake)) {
                    bestMove = n;
                    break; // –ë–µ—Ä–µ–º –ø–µ—Ä–≤—ã–π –ø–æ–ø–∞–≤—à–∏–π—Å—è –±–µ–∑–æ–ø–∞—Å–Ω—ã–π
                }
            }
        }

        // 4. –ï—Å–ª–∏ —Å–æ–≤—Å–µ–º –≤—Å—ë –ø–ª–æ—Ö–æ - –ª—é–±–æ–π –≤–∞–ª–∏–¥–Ω—ã–π —Ö–æ–¥
        if (!bestMove) {
            const valid = getNeighbors(head).filter(n => isValid(n, snake));
            if (valid.length > 0) bestMove = valid[0];
        }

        if (bestMove) {
            dir = {x: bestMove.x - head.x, y: bestMove.y - head.y};
        }
    }

    // –ü–æ–∏—Å–∫ –ø—É—Ç–∏ (–≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –º–∞—Å—Å–∏–≤ —à–∞–≥–æ–≤)
    function bfs(start, target, body) {
        const q = [[start]];
        const visited = new Set([start.x+','+start.y]);
        const blocks = new Set(body.map(p => p.x+','+p.y));
        
        while (q.length) {
            const path = q.shift();
            const curr = path[path.length-1];
            if (curr.x === target.x && curr.y === target.y) return path.slice(1);
            
            getNeighbors(curr).forEach(n => {
                const k = n.x+','+n.y;
                if (!visited.has(k) && !blocks.has(k)) {
                    visited.add(k);
                    q.push([...path, n]);
                }
            });
        }
        return [];
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç–∏–∂–∏–º–æ—Å—Ç–∏ (–≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç true/false) - –ë—ã—Å—Ç—Ä–µ–µ —á–µ–º –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å –ø—É—Ç—å
    function canReach(start, target, body) {
        // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è: –Ω–µ –∏—â–µ–º –ø–æ–ª–Ω—ã–π –ø—É—Ç—å, –ø—Ä–æ—Å—Ç–æ –µ—Å—Ç—å –ª–∏ –æ–Ω
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º BFS, –Ω–æ –±–µ–∑ —Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—É—Ç–µ–π
        const q = [start];
        const visited = new Set([start.x+','+start.y]);
        const blocks = new Set(body.map(p => p.x+','+p.y));
        // –•–≤–æ—Å—Ç –≤—Å–µ–≥–¥–∞ —è–≤–ª—è–µ—Ç—Å—è –¥–æ–ø—É—Å—Ç–∏–º–æ–π –∫–ª–µ—Ç–∫–æ–π –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è (–æ–Ω —É–π–¥–µ—Ç), –µ—Å–ª–∏ –º—ã –Ω–µ –µ–¥–∏–º.
        // –ù–æ –≤ –ø—Ä–æ–≤–µ—Ä–∫–µ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –º—ã —á–∞—Å—Ç–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç–∏–∫—É. 
        // –†–∞–∑—Ä–µ—à–∏–º —Ö–≤–æ—Å—Ç –∫–∞–∫ —Ü–µ–ª—å.
        blocks.delete(target.x+','+target.y);

        while (q.length) {
            const curr = q.shift();
            if (curr.x === target.x && curr.y === target.y) return true;
            
            getNeighbors(curr).forEach(n => {
                const k = n.x+','+n.y;
                if (!visited.has(k) && !blocks.has(k)) {
                    visited.add(k);
                    q.push(n);
                }
            });
        }
        return false;
    }

    function getNeighbors(p) {
        return [
            {x:p.x, y:p.y-1}, {x:p.x, y:p.y+1},
            {x:p.x-1, y:p.y}, {x:p.x+1, y:p.y}
        ].filter(n => n.x>=0 && n.x<TILE_COUNT && n.y>=0 && n.y<TILE_COUNT);
    }

    function isValid(p, body) {
        // –ö–ª–µ—Ç–∫–∞ –≤–∞–ª–∏–¥–Ω–∞, –µ—Å–ª–∏ –Ω–µ —Å—Ç–µ–Ω–∞ (—É–∂–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ –≤ getNeighbors) –∏ –Ω–µ —Ç–µ–ª–æ
        // –•–≤–æ—Å—Ç —Å—á–∏—Ç–∞–µ–º —Å–≤–æ–±–æ–¥–Ω—ã–º
        const tail = body[body.length-1];
        if (p.x === tail.x && p.y === tail.y) return true;
        return !body.some(b => b.x === p.x && b.y === p.y);
    }

    // --- –û–¢–†–ò–°–û–í–ö–ê ---
    function draw() {
        // –§–æ–Ω
        ctx.fillStyle = COLOR_BG_1;
        ctx.fillRect(0, 0, width, height);
        
        // –®–∞—Ö–º–∞—Ç–∫–∞
        ctx.fillStyle = COLOR_BG_2;
        for(let x=0; x<TILE_COUNT; x++) {
            for(let y=0; y<TILE_COUNT; y++) {
                if ((x+y)%2===0) ctx.fillRect(x*tileSize, y*tileSize, tileSize, tileSize);
            }
        }

        // –ï–¥–∞
        const fx = food.x * tileSize + tileSize/2;
        const fy = food.y * tileSize + tileSize/2;
        ctx.fillStyle = COLOR_FOOD;
        ctx.beginPath(); ctx.arc(fx, fy, tileSize*0.35, 0, Math.PI*2); ctx.fill();

        // –ó–º–µ—è
        snake.forEach((s, i) => {
            const sx = s.x * tileSize + tileSize/2;
            const sy = s.y * tileSize + tileSize/2;
            ctx.fillStyle = (i===0) ? '#fff' : COLOR_SNAKE;
            ctx.beginPath(); ctx.arc(sx, sy, tileSize*0.4, 0, Math.PI*2); ctx.fill();
        });
    }

    function updateUI() {
        document.getElementById('score-val').innerText = score;
    }

    function toggleAI() {
        isAI = !isAI;
        const btn = document.getElementById('btn-toggle-ai');
        const badge = document.getElementById('ai-status');
        if (isAI) {
            btn.classList.add('active');
            badge.innerText = "SURVIVAL AI";
            badge.style.color = "#00E676";
        } else {
            btn.classList.remove('active');
            badge.innerText = "MANUAL";
            badge.style.color = "#888";
        }
    }

</script>
</body>
</html>